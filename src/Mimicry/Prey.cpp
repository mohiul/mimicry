/**
 * \file Prey.cpp
 */

#include <iostream>
#include <iomanip>
#include <list>
#include "Agent.h"
#include "Model.h"
#include "randutil.h"

/**
 * Construct a Prey species.
 * Also sets up OpenGL texture properties.
 * \param _model The \a Model this Prey is part of.
 * \param _cell The \a Cell this Prey currently resides.
 * \param _position The current position of this Agent.
 * \param _genome \a Genome of this species. 
 */
Prey::Prey(Model* _model, 
		   Cell* _cell, 
		   formal::Vector _position, 
		   Genome<PREY_GENE_SIZE> _genome)
{
	model = _model;
	cell = _cell;
	position = _position;
	genome = _genome;
	velocity = 0.0;
	force = 0.0;
	age = 0;
	palatability = false;
	capableToReproduce = false;
	lastReproductionTime = 0;
	state = Agent::ALIVE;

	if(genome.get(16))
		capableToReproduce = true;

	geneIndex8to9();

	makeTexturedImage();

	//Setting OpenGL texture properties
	glEnable(GL_DEPTH_TEST);

	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glGenTextures(1, &texName);
	glBindTexture(GL_TEXTURE_2D, texName);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, PATTERN_SIZE, PATTERN_SIZE, 
				0, GL_RGBA, GL_UNSIGNED_BYTE, texturedImage);
}

/**
 * Draw textured \a Prey species from pattern generated by Cellular Automata.
 */
void Prey::draw()
{
	glColor3f(1.0, 1.0, 1.0);
	glPushMatrix();
	glTranslatef(position[0], position[1], position[2]);
	
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
	glBindTexture(GL_TEXTURE_2D, texName);

	glBegin(GL_QUADS);
	glTexCoord2f(0.0, 0.0); glVertex3f(-0.1 * System::PREY_SIZE, -0.1 * System::PREY_SIZE, 0.0);
	glTexCoord2f(0.0, 1.0); glVertex3f(-0.1 * System::PREY_SIZE,  0.1 * System::PREY_SIZE, 0.0);
	glTexCoord2f(1.0, 1.0); glVertex3f( 0.1 * System::PREY_SIZE,  0.1 * System::PREY_SIZE, 0.0);
	glTexCoord2f(1.0, 0.0); glVertex3f( 0.1 * System::PREY_SIZE, -0.1 * System::PREY_SIZE, 0.0);
	glEnd();
	glDisable(GL_TEXTURE_2D);

	glPopMatrix();
}

/**
 * Operations preformed in every step for by a \a Prey.
 * Age update. Add force for mobility based on genome. 
 * Find crowds of \a Prey to move towards.
 */
void Prey::step()
{
	age++;
	force = formal::Vector(0, 0, 0);
	geneIndex10to15();
	if(age >= System::PREY_REPRODUCTION_AGE_LIMIT 
		&& ( lastReproductionTime + System::PREY_REPRODUCTION_INTERVAL ) < model->getSimTime())
		geneIndex16();
	if(age > System::PREY_DEMISE_AGE)
		kill();
	else
		move();
}

/**
 * Move an \a Agent.
 * This function is called once during each step by the \a Model.
 * It uses the force component of the Agent to compute the Agent's acceleration.
 * If the force and velocity are both zero, it has no effect.
 * Otherwise, Newton's law is used to obtain the acceleration, which is
 * integrated to obtain the new velocity and new position.
 */
void Prey::move()
{
    formal::Vector acceleration = System::FORCE_FACTOR * force - System::FRICTION * velocity;
    velocity += System::DT * acceleration;
    formal::Vector deltaPos = System::DT * velocity;
	position += deltaPos;
	model->checkPosition(position);
}
/**
 * Create textured image from pattern generated from Cellular Automata.
 */
void Prey::makeTexturedImage()
{
   int i, j, c;

   int patternColor = 255;
   if(palatability)
	   patternColor = 200;

   pattern.generatePattern(&genome);
   for (i = 0; i < PATTERN_SIZE; i++) {
      for (j = 0; j < PATTERN_SIZE; j++) {
		if (pattern.get(i, j) == 0)
			c = 0;
		else if (pattern.get(i, j) == 1)
			c = patternColor;
		texturedImage[i][j][0] = (GLubyte) c;
		texturedImage[i][j][1] = (GLubyte) c;
		texturedImage[i][j][2] = (GLubyte) c;
		texturedImage[i][j][3] = (GLubyte) 255;
      }
   }
}

/**
 * Perform action based on the gene index 8 to 9. These are palatability
 * genes. Two bits are used to represent four levels of palatability. 
 */
void Prey::geneIndex8to9()
{
	int palatabilityLevel = genome.get(9)*2 + genome.get(8)*1;
	if (palatabilityLevel < 2)
		palatability = true;
}

/**
 * Perform action based on the gene index 10 to 15. These are mobility
 * genes. These six bits are used to calculate the force with which \a Prey
 * species try to move towards any neighbourhood cell. The algorithm sorts
 * all neighbouring cell descending to the number of prey species. Then it 
 * selects the cell which contains the highest number of prey with zero predator.
 * If all the neighbouring cells contain predators, then the algorithm sorts the
 * neighbouring cells descending to the number of predators and chooses the one
 * which contains the least.
 */

void Prey::geneIndex10to15()
{
	int forceMagnitude = genome.get(10)*1 + genome.get(11)*2 + genome.get(12)*3
		+ genome.get(13)*4 + genome.get(14)*5 + genome.get(15)*6;
	
	Cell *best = cell;

	std::list<Cell*> sortedNeighbours = cell->getSortedNeighbours(Agent::PREY);

	bool cellFound = false;
	
	for (std::list<Cell*>::iterator cellIter = sortedNeighbours.begin();
		cellIter != sortedNeighbours.end(); cellIter++)
		if((*cellIter)->getPop(Agent::PREDATOR) == 0)
		{
			best = (*cellIter);
			cellFound = true;
			break;
		}

	if(!cellFound)
	{
		sortedNeighbours = cell->getSortedNeighbours(Agent::PREDATOR);
		best = *--sortedNeighbours.end();
	}

	if (best != cell)
		addForce(forceMagnitude * offset(best, cell));
}

/**
 * Perform action based on the gene index 16. These are reproduction
 * genes. If this gene is enabled, Prey species are capable to 
 * reproduce. Prey chooses another random Prey within its cell
 * for reproduction. The random selected Prey has to have similar
 * pattern to be able to reproduce.
 */
void Prey::geneIndex16()
{
	int preyPop = cell->getPop(Agent::PREY);
	if(capableToReproduce && preyPop >= 1)
	{
		int rand = randomInteger(preyPop);
		std::list<Agent*> agentList = cell->getAgentList();
		int preyCount = 0;
		for(std::list<Agent*>::iterator agentIter = agentList.begin();
			agentIter != agentList.end(); agentIter++)
			if((*agentIter) != this && (*agentIter)->getState() == Agent::ALIVE 
				&& (*agentIter)->getAgentType() == Agent::PREY
				&& preyCount++ == rand
				&& ((Prey*)*agentIter)->pattern == this->pattern
				&& ((Prey*)*agentIter)->isPalatable() == this->isPalatable())
					reproduce(*agentIter);
	}
}

/**
 * Reproduce and mutate with another \a Prey.
 * \param agent Prey species with which the reproduction process will take place.
 * If the randomly selected Prey is capable to reproduce, then a crossover
 * is performed among both its genome with the selected Prey giving birth to a new Prey
 * and adding it to a randomly choosen neighbourhood cell. Mutation on the new born is
 * performed separately on the pattern genome and the rest of the genome using two 
 * different mutation rate.
 */
void Prey::reproduce(Agent* agent)
{
	Prey* prey = static_cast<Prey*>(agent);
	if(prey->isCapableToReproduce())
	{
		Genome<PREY_GENE_SIZE> newGenome = genome.crossOverExceptPatternGene(prey->getGenome());

		if(System::PREY_GENOME_MUTATION_RATE * 100 > randomInteger(100))
			newGenome.mutateExceptPatternGene();

		if(System::PATTERN_MUTATION_RATE * 100 > randomInteger(100))
			newGenome.mutatePatternGene();

		Cell* randomNeighbour = cell->getNeighbour(randomInteger(NUM_CELL_NEIGHBOURS));
		cell->insert(new Prey(model, randomNeighbour, randomNeighbour->getPos(), newGenome));
		this->lastReproductionTime = model->getSimTime();
		prey->lastReproductionTime = model->getSimTime();
	}
}

/**
 * Kill this \a Prey.
 */
void Prey::kill()
{
	state = Agent::DEAD;
	cell->reducePop(Agent::PREY);
}
